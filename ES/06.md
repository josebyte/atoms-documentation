#Atoms
## 6 - Eventos

Como vimos en el capítulo destinado a los elementos *Molecule*, Atoms ofrece un sistema de comunicación entre elementos basado en el patrón de comunicación Bubbling/Tunneling. En este capítulo descubrirás como manejar estos eventos además de otros como *bind*/*trigger* o los *entity bindings*.


### 6.1 Bubbling
El evento *Bubble* se basa en una comunicación desde los elementos más simples, los Atom, hasta los elementos más complejos, los Organism. Esta comunicación se va transportando por toda la herencia superior hasta llegar a un handler que capture ese evento, por ejemplo tenemos la siguiente estructura:

**YAML**

```
- Organism.Article
    id: main
    children:
      - Molecule.Form:
          children:
            - Atom.Input:
                type       : text
                placeholder: Your name...
                events     : ["keyup"]
            - Atom.Button
                text       : Send
                events     : ["touch"]
```

Como vemos tenemos un `Organism.Article` que contiene un `Molecule.Form` que a su vez contiene dos elementos del tipo `Atom`: `Input` y `Button`. El `Atom.Input` capturará cada vez que se pulse una tecla sobre si gracias a que le hemos asignado el evento `"keyup"` a su vez el elemento `Atom.Button` lanzará el  evento `"touch"`. Bien ahora vamos a hacer que la instancia de Organism.Article capture los eventos lanzados, como hemos comentado al principio son eventos de tipo Bubble por lo que estos se irán transportando por las jerarquias superiores hasta llegar a un handler (capturador) del evento. Veamos:

```
class Register extends Atoms.Class.Organism
  ...
  
  onInputKeyup: (event, dispatcher, hierarchy...) ->
    @
  
  onButtonTouch: (event, dispatcher, hierarchy...) ->
    @
```

Antes de continuar vamos a explicar la convención que existe en cuanto al *naming* de métodos, como ves en nuestra clase `Register` hemos creado 2 métodos: `onInputKeyup` y `onButtonTouch`. Atoms intenta ayudarte a la hora de clasificar métodos y para ellos utiliza una convención facil de identificar: `on + Class + Event` en el caso de que quisiesemos customizar el nombre del evento unicamente tendríamos que indicarlo en el elemento que dispare dicho evento. Por ejemplo vamos a hacer que el `Atom.Button` dispare un evento `onSend` en vez de `onButtonTouch` para ello tenemos que crear el atributo especial callbacks:

```
- Atom.Button:
    text     : send
    events   : ["touch"]
    callbacks: ["onSend"]
```

Ahora en nuestra clase `Register` tendríamos que modificar el nombre del *handler* por el definido en `callbacks`:

```
class Register extends Atoms.Class.Organism
  ...
  
  onInputKeyup: (event, dispatcher, hierarchy...) ->
    @
    
  onSend: (event, dispatcher, hierarchy...) ->
    @
```

Como podemos ver tanto el atributo events como callbacks son del tipo Array y esto es así porque un elemento puede contener más de un evento, por ejemplo vamos a hacer que Atom.Button además de "touch" se subscriba al evento "hold" que se disparará cuando sea pulsado durante más de 500ms:

```
- Atom.Button:
    text     : send
    events   : ["touch", "hold"]
    callbacks: ["onSend"]
```

Como vemos en `callbacks` no es necesario establecer un segundo nombre puesto que en este caso no lo vamos a sobreescribir desplegando así el evento por convención `onButtonHold`. Bien, ahora volvamos al *handler* de los eventos *Bubble*, como veíamos en nuestra clase register un handler se compone de 3 parametros: 

  - `event`: La información del evento en si, dependerá del tipo de evento (tactil, listener...)
  - `dispatcher`: El elemento que despliega el evento Bubble, resumiendolo el elemento origen.
  - `hierarchy...`: La jerarquia por la que se despliega el evento Bubble.
  
De esta manera si nos centramos en el evento onInputKeyup podemos ver todo lo que podemos llegar a hacer:

```
class Register extends Atoms.Class.Organism
  ...
  
  onInputKeyup: (event, dispatcher, hierarchy...) ->
    console.log event.keyCode
    
    dispatcher.el.attr "disabled", true
    
    console.log hierarchy[0].constructor
``` 

Como podemos leer imprimimos por pantalla el codigo *ASCII* que se esta pulsando en el `Atom.Input`, a su vez en dispatcher que hace referencia a ese mismo elemento lo bloqueamos utilizando el simbolo `el` y su método `attr` y por último consultamos cual ha sido el primer elemento por el que ha pasado el evento *Bubble* (en este caso Molecule.Form). Como puedes ver Atoms te ofrece toda la información necesaria para controlar un evento Bubble, ahora bien podemos incluso tener varios *handlers* del mismo evento por ejemplo ahora tanto en Register como en Molecule.Form vamos a capturar el evento `onSend`:

```
class Register extends Atoms.Class.Organism

  onSend: (event, dispatcher, hierarchy...) ->
    console.log "Organism", event, hierarchy.length


class Molecule.Form extends Atoms.Class.Molecule

  onSend: (event, dispatcher, hierarchy...) ->
    console.log "Molecule", event, hierarchy.length
``` 

Como vemos en ambos es de igual manera, aunque podríamos hacer que cada *handler* tratase de diferente manera el evento *Bubble*. En este caso cuando se pulsase sobre el `Atom.Button`,el cual tiene sobreescrito el evento a onSend, nuestra consola mostraría:

```
> "Molecule", {event}, 0
> "Organism", {event}, 1
```

Como vemos el orden de ejecución es el correcto, el evento va desplegandose por las jerarquias superiores pasando primeramente por *Molecule* y despues por el *Organism*. Como vemos en el primer caso el parametro `hierarchy` es `0` puesto que no ha pasado por mas contenedores, en cambio cuando llega al *Organism*  el valor es `1` puesto que ha pasado por `Molecule.Form`. Ahora vas a aprender como parar eventos para que no sean capturados por handlers de una jerarquia superior, vamos a hacer que el handler de `Molecule.Form` pare el evento de una manera muy sencilla simplemente devolviendo un valor `false`.

```
class Molecule.Form extends Atoms.Class.Molecule

  onSend: (event, dispatcher, hierarchy...) ->
    console.log "Molecule", event, hierarchy.length
    false 
```

De esta manera si volvemos a disparar el evento touch sobre nuestro Atom.Button vemos como esta vez solo aparecerá por consola el handler de Molecule.

```
> "Molecule", {event}, 0
```

El bloqueo de eventos puede serte de gran ayuda en determinadas ocaciones por ejemplo al continuar con el Bubbling cuando el evento cumpla determinadas reglas, o incluso para lanzar nuevos eventos. Vamos a poner especial interes en el despliegue de nuevos eventos Bubble, en el caso de los elementos Atom el despliegue es automático puesto que se trata de eventos del propio DOM. Vamos a hacer que nuestra Molecule.Form despliegue un nuevo evento Bubble llamando "change" cuando la tecla pulsada en Atom.Input sea un RETORNO (13):

```
class Molecule.Form extends Atoms.Class.Molecule
  
  onInputKeyup: (event, dispatcher, hierarchy...) ->
    if event.keyCode is 13
      @bubble "change", event
      false
```

Como podemos comprobar la creación de nuevos eventos Bubble es realmente sencilla, únicamente tenemos que utilizar el método interno `@bubble` el cual está disponible en los elementos: *Atom*, *Molecule* y *Organism*. Recibe dos parametros: el nombre del evento, en nuestro caso `"change"`, y la información del evento en si, en nuestro caso pasamos la información recibida del evento `"keyup"` emitido por `Atom.Input`. Unicamente con esos dos parametros Atoms se encarga del resto:
  
  - Establecer el naming correcto del handler: `onFormChange`.
  - Desplegar el evento por toda la jerarquia superior en busca de dicho handler.
  - Añadir a hierarchy cada uno de los elementos superiores por los que va pasando.  

Ahora solo nos quedaría crear el *handler* `onFormChange` en nuestra clase `Register`:

```
class Register extends Atoms.Class.Organism
  ...
  
  onFormChange: (event, dispatcher, hierarchy...) ->
    false
```

Todo lo aprendido hasta ahora sobre el *Bubbling* te será de gran ayuda a la hora de crear tus propias extensiones de Atoms, en el próximo capítulo verémos como hacerlo y podrás comprobar el verdadero potencial de la programación Atómica.


### 6.2 Tunneling
Los eventos de tipo tunnel mantienen el mismo concepto que el *Bubbling* salvando que en este caso el recorrido va de un elemento complejo, *Organism* por ejemplo, a un elemento más simple, *Molecule* o *Atom*. Dado que dentro de Atoms no es tan común este tipo de eventos y cada desarrollador puedo utilizarlo de diferentes maneras, tenemos toda la libertad a la hora de elegir el *naming* del *handler*.

Veamos un ejemplo, necesitamos que nuestro conocido organismo `Register` que extiende de `Atoms.Class.Organism` (elemento complejo) cuando capture el evento *bubble* `onSend` despliegue un evento *tunnel* a todos sus hijos llamado `"saving"`. Para ello harémos uso del método interno `@tunnel` el cual, al igual que `@bubble`, recibe 2 parametros: el nombre del evento y la información del mismo. Veamos el código:

```
class Register extends Atoms.Class.Organism
  ...
  
  onSend: (event, dispatcher, hierarchy...) ->
    @tunnel "onRegisterSaving", {}
```

Como vemos en el caso de los eventos *tunnel* debemos definir el nombre que queramos, en nuestro caso `onRegisterSaving` recogiendolo en `Atom.Button`:

```
class Atom.Button extends Atom.Class.Button
  
  onRegisterSaving: (event, dispatcher, hierarchy...) ->
    @el.attr "disabled", true
```

Como puedes leer lo que hacemos cuando se dispara el *handler* `onRegisterSaving` es bloquear el botón (añadiendo el atributo `disabled`), y como en el caso de los eventos *bubble* los paramentros que llegan al handler son los mismos: `event`, `dispatcher`, `hierarchy...`. 

Al tratarse del mismo paradigma no necesitas más explicación para comenzar a trabajar con el *Tunneling*, recordandote que la combinación con el *Bubbling* hace que Atoms sea un sistema muy extensible y parametrizable en cuanto a la comunicación de elementos.


### 6.3 Binding
El sistema de eventos *binding* es por todos conocidos y tambien esta presente en Atoms ofreciendo un sistema sencillo de publicación y suscripción. Para ello necesitamos 2 métodos:

  - `@trigger`: Publicador del evento
  - `@bind`: Suscriptor del evento

Difiere bastante del sistema de Bubbling/Tunneling ya que mientras esos eventos se definen de manera más dinamica en este caso tenemos que conocer las instancias en todo momento. Veamos un ejemplo parecido al realizado en el capítulo de *Bubbling*; 

**YAML**

```
- Organism.Article
    id: main
    children:
      - Molecule.Form:
          id: form
```

Tenemos un `Organism.Article` con id `main` el cual contiene un `Molecule.Form` con id `form`, como aprendimos en capítulos anteriores el utilizar el atributo nos da la posibildad de tener una referencia simbólica al elemento desde su padre; de esta manera en `main` podremos controlar `form` y es este último quien va a publicar un evento `"created"`, veamos como:

```
class Molecule.Form extends Atoms.Class.Molecule
  
  constructor: ->
    super
    @trigger "created"
```

Únicamente hemos sobreescrito el constructor base de `Class.Molecule` dejando que realice todo lo que tiene que hacer la base, de ahí `super`, y tras ello publicamos el evento `"created"` con el método interno `@trigger`. Es realmente sencillo, al igual que en los eventos bubbling/tunneling, podemos enviar un segundo parametro con la información del evento (aunque en este caso no lo harémos). Ahora vamos a suscribirnos desde *main* al evento que lanza nuestra `Molecule.Form`:

```
class Organism.Article extends Atoms.Class.Organism
  
  render: ->
    super
    @form.bind "created", onFormCreated
   
  onFormCreated: (event, args...) ->
    console.log "Form is created"
```

En este caso no sobreescribimos el `constructor` ya que como aprendimos en el capítulo destinado a *Organism* el elemento no se crea hasta que llamemos al método interno `render` y por lo tanto tanto el *Organism* como todos sus *children* no son accesibles. Al haber establecido el atributo id de `Molecule.Form` a `"form"` podemos acceder a el desde el simbolo `@form` y por lo tanto podemos utilizar su método `bind` el cual se ejecutará cuando en tu aplicación se llame al método `trigger` de la misma instancia. El método bind recibe dos parametros, el nombre del evento `bind` que queremos suscribirnos y la función que queremos que se ejecute cuando se publique un evento, en nuestro caso `onFormCreated`. Este *callback* recibe varios argumentos, la información del evento (en el caso de que dispongamos de ello), y el resto de argumentos.

Como ves el sistema de eventos *Binding* difiere bastante del *Bubbling*/*Tunneling* aunque en ciertas ocasiones resulta más comodo que estos últimos. Cuando estudies la extension `Atoms.App` podrás comprobar que ambos sistemas conviven y se utilizan de manera muy diferenciada.


### 6.4 Entity Binding
En el capítulo anterior conocimos el elemento Entity el cual se encargaba de gestionar la información de nuestra aplicación en un sistema interno. Entity es un elemento especial de Atoms ya que no tiene vinculo con el pseudo-DOM y para ello necesita combinarse con otros elementos que si tengan ese vinculo, en este caso *Molecule* y *Atom*. Verémos las diferencias entre cada uno de ellos 